---
title: "HMM filtering of scalar SDEs"
author: "Uffe HÃ¸gsbro Thygesen"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{HMM filtering of SDEs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


## Overview 

We simulate a sample path from the Ito stochastic differential equation governing the abundance of a bacterial population

\[
dX_t = (1- X_t) ~dt + \gamma \sqrt{X_t} ~dB_t
\]

which is the Cox-Ingersoll-Ross model. Then, we simulate random measurements taken at times $0,dt,2~dt, \ldots, T$ so that $Y_i | X_{t_i}$ is Poisson distributed with mean $v `. X_{t_i}$. Then, we pretend that we don't know the states and re-estimate them from these measurements. 

We first simulate states and measurements: 

```{r,fig.width=8}
  require(SDEtools)

  # Define model. Note abs to handle negative x.
  gamma <- 1
  f = function(x) (1-x)
  g = function(x) gamma * sqrt(abs(x));

  # Advection-diffusion form
  D = function(x) 0.5*gamma^2*x;
  u = function(x) f(x) - 0.5*gamma^2;

  ## Time vector for simulation
  dt = 0.001;
  Tmax = 20;

  tvec = seq(0,Tmax,dt)
  nt <- length(tvec)

  ## Initial condition, chosen somewhat arbitrarily
  x0 <- 4

  ## Enforce that the simulated state should be non-negative
  p <- function(x) abs(x)
  
  ## Simulate states 
  sim <- euler(f,g,tvec,x0,p=p)
  
  plot(sim$times,sim$X,type="l",xlab="Time",ylab='Abundance')

  ## Generate random measurements
  tsample <- 0.1
  vsample <- 1

  sampleIndeces <- round(seq(1,length(tvec),(tsample/dt)))
  tm = tvec[sampleIndeces];
  ymean = vsample * sim$X[sampleIndeces];

  # Generate random measurements
  ymeas <- rpois(length(tm),lambda=ymean)

  points(tm,ymeas/vsample,pch='o')
```

We now run the filter. We first specify the likelihood function, and then call HMMfilterSDE.

```{r,fig.width=8,fig.height=6}

  ## Data likelihood
  dl <- function(x,y) dpois(y,lambda=vsample*x)

  ## Choose discretization of state space
  xi <- seq(0,3,0.025)^2                                # Cell Interfaces
  xc <- head(xi,-1) + 0.5*diff(xi)
  
  ## Specify prior c.d.f. of the initial state, here uniform. Note that it does not have to be normalized.
  phi0 <- function(x)x
  ## Run the filter 
  filter <- HMMfilterSDE(u,D,xi,bc='r',phi0,tm,ymeas,dl)

  ## Show colour plot of posterior c.d.f.
  image(tm,xc,t(apply(filter$psi,1,cumsum)),ylim=c(0,4))

  ## Add true state at times of measurements
  lines(tm,ymean/vsample)

  ## Compute and plot posterior mean
  XestMean <- filter$psi %*% xc
  points(tm,XestMean,pch="x")
```

