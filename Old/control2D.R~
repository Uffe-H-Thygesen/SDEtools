require(SDEtools)
require(fields)
require(pracma)

graphics.off()

Rprof()

## Lotka-Volterra system in x=log(N), y= log(P)
xgrid <- seq(-5,1,length=61)
ygrid <- seq(-5,1,length=62)

nx <- length(xgrid)-1
ny <- length(ygrid)-1

xc <- 0.5*(head(xgrid,-1) + tail(xgrid,-1))
yc <- 0.5*(head(ygrid,-1) + tail(ygrid,-1))

dx <- mean(diff(xgrid))
dy <- mean(diff(ygrid))

centers <- cell.centers(xgrid,ygrid)
xx <- pack.field(centers$x)
yy <- pack.field(centers$y)

r <- 1
e <- 1
mu <- 1/2

ux <- function(x,y) r*(1-exp(y)-mu*exp(x)) # 1-exp(x) # 
uy <- function(x,y) e*(exp(x)-1) # 1-exp(y) # 

Dx <- function(x,y) 0.01
Dy <- function(x,y) 0.01

## Stochastic Rosenzweig-MacArthur model: x=log(N), y=log(P)
r <- 1
K <- 1
c <- 2.5
mu <- 0.15
Nbar <- 1.5
e <- 0.22

ux <- function(x,y) r*(1-exp(x)/K) - c*exp(y)/(exp(x)+Nbar) - Dx(x,y)
uy <- function(x,y) e*c*exp(x)/(exp(x)+Nbar) - mu - Dy(x,y)

G0 <- fvade2d(ux,uy,Dx,Dy,xgrid,ygrid)
pi <- StationaryDistribution(G0)

pi.field <- unpack.field(pi,nx,ny)/dx/dy

image.plot(xgrid,ygrid,t(pi.field))
pracma::quiver(xx,yy,ux(xx,yy),uy(xx,yy))

## Controls: Fisheries 1 on prey, 2 on predators. The control is the mortality
ux1 <- function(x,y) -1
uy1 <- function(x,y) 0

ux2 <- function(x,y) 0
uy2 <- function(x,y) -1

Dnull <- function(x,y) 0

G1 <- fvade2d(ux1,uy1,Dnull,Dnull,xgrid,ygrid)
G2 <- fvade2d(ux2,uy2,Dnull,Dnull,xgrid,ygrid)

## Optimal harvest. Maximize sqrt(C1)+sqrt(C2)
p1 <- 0.15
p2 <- 1
Fmax <- 3

u1 <- function(G1V) pmin(Fmax*(xx>min(xx)),pmax(p1^2*exp(xx)/4/pmin(G1V,-1e-10)^2,0))
u2 <- function(G2V) pmin(Fmax*(yy>min(yy)),pmax(p2^2*exp(yy)/4/pmin(G2V,-1e-10)^2,0))
uopt <- list(u1,u2)

## Payoff
k <- function(u) p1*sqrt(u[,1]*exp(xx))+p2*sqrt(u[,2]*exp(yy))

sol <- PolicyIterationSingular(G0,list(G1,G2),k,uopt,do.minimize=FALSE,verbose=TRUE)

dev.new()
par(mfrow=c(2,2))
image.plot(xgrid,ygrid,t(unpack.field(pmin(0.5,sol$u[,1]),nx,ny)))
image.plot(xgrid,ygrid,t(unpack.field(pmin(0.5,sol$u[,2]),nx,ny)))
image.plot(xgrid,ygrid,t(unpack.field(sol$pi/dx/dy,nx,ny)))
image.plot(xgrid,ygrid,t(unpack.field(sol$V,nx,ny)))

quiver <- function(u)
{
    # scale assume uniform grid!
    dx <- as.numeric(-u[,1])
    dy <- as.numeric(-u[,2])

    scale <- min(max(diff(xgrid))/max(abs(dx)),max(diff(ygrid))/max(abs(dy)))
    arrows(xx,yy,xx+scale*dx ,yy + scale*dy,length=0.1,angle=10)
}

I <- seq(1,length(xx),10)
# quiver(sol$u)
## pracma::quiver(x=xx[I],y=yy[I],u=-sol$u[I,1],v=-sol$u[I,2])

Rprof(NULL)

## Simulate close loop using the discrete-time generato
Gc <- G0 + Diagonal(x=sol$u[,1]) %*% G1 + Diagonal(x=sol$u[,2]) %*% G2

## Simulate a Markov chain
simulate <- function(G,i0,T,Nmax=Inf)
{
    Gt <- t(G)
    
    i <- numeric(min(Nmax,1e4))
    t <- i
    j <- 1

    i[1] <- i0
    
    while(TRUE)
    {
        lambda <- -G[i[j],i[j]]

        if(lambda==0) break
        
        t[j+1] <- t[j] + rexp(n=1,rate=lambda)

        ## Extract vector of next states as a sparse vector
        v <- Gt[,i[j],drop=FALSE]

        ##
        p <- pmax(0,v@x)
        p <- p/sum(p)

        i[j+1] <- v@i[sample(length(p),size=1,replace=TRUE,prob=p)] + 1

        if(t[j+1] > T) break
        if(j>=Nmax) break

        if( (j+1) == length(i) ) {
            i <- c(i,numeric(1e4))
            t <- c(t,numeric(1e4))
        }

        j <- j+1

    }

    i <- i[1:j]
    t <- t[1:j]
    
    return(list(t=t,i=i))
}

U1 <- unpack.field(sol$u[,1],nx,ny)
U2 <- unpack.field(sol$u[,2],nx,ny)

f <- function(xy)
{
    x <- min(max(xy[1],xc[1]),xc[length(xc)])
    y <- min(max(xy[2],yc[1]),yc[length(yc)])

    u1 <- interp2(xc,yc,U1,xp=x,yp=y)
    u2 <- interp2(xc,yc,U2,xp=x,yp=y)

    return(c(ux(x,y) - u1,uy(x,y) - u2))
}

## Use that the diffusivity is constant - otherwise we need to convert from advection to drift
sx <- sqrt(2*Dx())
sy <- sqrt(2*Dy())

g <- function(xy)
    return(diag(c(sx,sy)))

stop()

simSDE <- SDEtools::euler(f,g,seq(0,2000,0.01),x0 =c(-3,-3))
sim <- simulate(Gc,i0=1,T=2000)

dev.new()
par(mfrow=c(1,2))
image.plot(xgrid,ygrid,t(unpack.field(sol$pi/dx/dy,nx,ny)))
image.plot(xgrid,ygrid,t(unpack.field(sol$pi/dx/dy,nx,ny)))
lines(xx[sim$i]+rnorm(length(sim$i),sd=0.5*dx),yy[sim$i]+rnorm(length(sim$i),sd=0.5*dx))
lines(simSDE$X[,1],simSDE$X[,2],col="blue")
