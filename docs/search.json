[{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/BrownianMotion.html","id":"simulation-of-brownian-motion","dir":"Articles","previous_headings":"","what":"Simulation of Brownian motion","title":"Brownian Motion","text":"Given set time points, straightforward simulate Brownian motion restricted time points:  simulation routine starts finding time increments. random Gaussian variables simulated increment, using increments Brownian motion independent variance scales time. Finally increments added obtain Brownian motion . coded function rBM:","code":"require(SDEtools) ## Loading required package: SDEtools tv <- c(0,1,2,4) B <- rBM(tv) plot(tv,B,type=\"b\",xlab=\"t\",ylab=expression(B[t])) print(rBM) ## function (times, sigma = 1, B0 = 0, u = 0)  ## { ##     dt <- c(times[1], diff(times)) ##     dB <- rnorm(length(times), mean = u * dt, sd = sigma * sqrt(dt)) ##     B <- B0 + cumsum(dB) ##     return(B) ## } ## <bytecode: 0x55ef6a7f5668> ## <environment: namespace:SDEtools>"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/BrownianMotion.html","id":"verifying-the-statistics-of-brownian-motion","dir":"Articles","previous_headings":"","what":"Verifying the statistics of Brownian motion","title":"Brownian Motion","text":"Let us generate large number sample paths time discretization check statistics. Compare analytical result:","code":"n <- 1000 B <- replicate(n,rBM(tv))  cov(t(B)) ##      [,1]      [,2]     [,3]      [,4] ## [1,]    0 0.0000000 0.000000 0.0000000 ## [2,]    0 0.9938048 0.947972 0.9669428 ## [3,]    0 0.9479720 1.871010 1.8274389 ## [4,]    0 0.9669428 1.827439 3.8345452 outer(tv,tv,Vectorize(function(x,y)min(x,y))) ##      [,1] [,2] [,3] [,4] ## [1,]    0    0    0    0 ## [2,]    0    1    1    1 ## [3,]    0    1    2    2 ## [4,]    0    1    2    4"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/BrownianMotion.html","id":"scaling-properties-of-brownian-motion","dir":"Articles","previous_headings":"","what":"Scaling properties of Brownian motion","title":"Brownian Motion","text":"Brownian motion scales square root time:","code":"tv <- seq(0,1,1e-5) B <- replicate(3,rBM(tv))  par(mfrow=c(1,2)) matplot(tv,B,type=\"l\",lty=1,ylim=c(-2,2)) lines(tv,sqrt(tv),lty=\"dashed\") lines(tv,-sqrt(tv),lty=\"dashed\") matplot(tv,B,type=\"l\",lty=1,ylim=c(-0.2,0.2),xlim=c(0,0.01)) lines(tv,sqrt(tv),lty=\"dashed\") lines(tv,-sqrt(tv),lty=\"dashed\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/BrownianMotion.html","id":"the-brownian-bridge","dir":"Articles","previous_headings":"","what":"The Brownian bridge","title":"Brownian Motion","text":"Given two end points, can simulate Brownian bridge connects . , simulate Brownain motion conditionally end points.  can verify statistics plotting mean variance bridge:","code":"tv <- 10:20   n <- 1e4   B0T <- c(15,5)   sigma <- 2   BB <- replicate(n,rBrownianBridge(tv,sigma=sigma,B0T=B0T))      matplot(tv,BB[,1:10],type=\"l\",lty=1) par(mfrow=c(1,2)) plot(tv,apply(BB,1,mean),xlab=\"t\",ylab=\"mean\") lines(range(tv),B0T) plot(tv,apply(BB,1,var),xlab=\"t\",ylab=\"var\") lines(tv,sigma^2*(tv-tv[1])*(1-(tv-tv[1])/diff(range(tv))))"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/BrownianMotion.html","id":"simulation-of-the-maximum-of-brownian-motion","dir":"Articles","previous_headings":"","what":"Simulation of the maximum of Brownian motion","title":"Brownian Motion","text":"study maximum Brownian motion, well maximum absolute value. maximum analytical result: \\[ \\mathbf{P}(S_t \\geq x) = 2\\mathbf{P}( B_t \\geq x)  \\] \\[ S_t= \\max\\{ B_s : 0\\leq s \\leq t \\} \\] max-abs, bound \\[ \\mathbf{P}(\\bar S_t \\geq x) \\leq 4\\mathbf{P}( B_t \\geq x)  \\] \\[ \\bar S_t= \\max\\{ |B_s| : 0\\leq s \\leq t \\} \\] following code simulates number sample paths Brownian motion \\(B_t\\) time interval \\(t=0,\\ldots,Nt\\). sample path compute maximum well maximum absolute value. plot empirical statistics maximum, max-abs, analytical approximations. statistics histogram, compared probability density function (pdf), complementary cumulated distribution function (ccdf), also referred survival function. first try comparison using 1000 sample paths (sufficient) 1000 time steps:  see excellent agreement maximum theoretical prediction. max-abs, see good agreement tail, .e. high values \\(x\\), poor agreement low values \\(x\\). reason disagreement bound \\(\\mathbf{P}(\\bar S_t \\geq x)\\) obtained ignoring probability maximum exceeds \\(x\\) time minimum exceeds \\(-x\\). \\(x\\) small, error becomes large. next graph repeats small number time steps, \\(Nt=10\\).  see poor agreement everywhere now. reason difference continuous-time maximum \\[ \\max\\{ B_s : 0 \\leq s \\leq t\\} \\] maximum sampled process \\[ \\max\\{ B_s : s=0,1,\\ldots,t\\} \\] \\(t\\) small, difference becomes important.","code":"require(SDEtools)  hist.maxBM.compare.analytical.Monte.Carlo <- function(Nt,Np) {    ## Simulate Np trajectories of BM on {0,1,...,Nt}   B <- rvBM(0:Nt,Np)      ## Compute max(B) and max(abs(B))   maxB <- apply(B,2,max)   maxabsB <- apply(B,2,function(x)max(abs(x)))    ## Histogram of max(B) vs theoretical p.d.f.     hist(maxB,freq=FALSE,xlab=\"x\",ylab=\"P.d.f.\",        main=\"Pdf of max(BM)\")   plot(function(x)2*dnorm(x,sd=sqrt(Nt)),from=0,to=max(maxB),add=TRUE)    ## Empirical vs. theoretical survival function of max(B)   plot(sort(maxB),seq(1,0,length=Np),type=\"s\",xlab=\"x\",ylab=\"Ccdf, P(X>x)\",        main=\"Ccdf of max(BM)\")   plot(function(x)2-2*pnorm(x,sd=sqrt(Nt)),from=0,to=max(maxB),add=TRUE)    ## Empirical vs. approximate theoretical survival function of max(abs(B))   plot(sort(maxabsB),seq(1,0,length=Np),type=\"s\",xlab=\"x\",ylab=\"Ccdf, P(X>x)\",     main=\"Ccdf of max(abs(BM)\")   plot(function(x)4*(1-pnorm(x,sd=sqrt(Nt))),from=0,to=max(maxB),add=TRUE) } hist.maxBM.compare.analytical.Monte.Carlo(Nt=1000,Np=1000) hist.maxBM.compare.analytical.Monte.Carlo(Nt=10,Np=1000)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/FisheriesManagement.html","id":"fisheries-as-optimal-control","dir":"Articles","previous_headings":"","what":"Fisheries as optimal control","title":"Fisheries Management - a Numerical Optimal Control Problem","text":"Following textbook, consider problem optimal harvest fish stock. objective vignette demonstrate numerical solution optimal control problem. controlled system dynamics \\[ dX_t = [ X_t(1-X_t) - U_t] ~dt + \\sigma X_t ~dB_t \\] , \\(X_t\\) biomass, \\(B_t\\) standard Brownian motion. term \\(X_t(1-X_t)\\) growth without fishing, .e. logistic growth; made time abundance dimensionless. \\(U_t\\) harvest rate. aim maximize \\(\\sqrt{U_t}\\) steady state, leads Hamilton-Jacobi-Bellman equation \\[ \\sup_{u\\geq 0} \\left[ \\dot V + x(1-x) V' - uV' + \\frac 12 \\sigma^2 x^2 V'' + \\sqrt u \\right] = 0 .  \\] optimal control found stationary point: \\(u= 1/4/(V')^2\\). analytical solution problem \\[   V(x,t) = \\frac 12 \\log x -\\gamma t \\] \\(\\gamma = \\frac 12 (1-\\sigma^2 /2)\\).","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/FisheriesManagement.html","id":"numerical-analysis-of-the-steady-state-problem","dir":"Articles","previous_headings":"","what":"Numerical analysis of the steady-state problem","title":"Fisheries Management - a Numerical Optimal Control Problem","text":"aim verify analytical solution numerically. first set model, writing advection-diffusion form. use \\(D=g^2/2\\) diffusivity \\(v=f-D'\\) advective field. following function gives optimal control function \\(x\\) \\(V'(x)\\): now discretize problem. use grid dense near origin. first define generator without fishing: next generator corresponding fishing: Note discretizes operator \\(V\\mapsto -V'\\). now almost ready solve steady-state problem using policy iteration. first, make nummerics robust, make two changes: First, left cell, assume fish. avoids option driving fish extinction fish like crazy fish aren’t . Next, assume bound harvest, even \\(V'(x)=0\\). replacing \\(V'(x)\\) \\(\\max(epsilon,V'(x))\\) \\(\\epsilon\\) “small” number. Finally, need pay-: can now solve steady-state problem using policy iteration: plot policy value function compared analytical results:  Note excellent agreement. Similarly, control:  Note discrepancy upper boundary, discretized problem fishes really hard avoid risk hitting boundary, wasteful. finally plot stationary distribution state time-invariant control.","code":"require(SDEtools) ## Loading required package: SDEtools sigma <- 0.5  f <- function(x) x*(1-x) g <- function(x) sigma*x  dg <- function(x) sigma D <- function(x) 0.5*g(x)^2 dD <- function(x) g(x)*dg(x) v <- function(x) f(x) - dD(x) mu <- function(x,Vp) 0.25/Vp^2 Xmax <- 4 xi <- seq(0,sqrt(Xmax),length=101)^2    # Interfaces between grid cells xc <- 0.5*(head(xi,-1)+tail(xi,-1))     # Center of grid cells G0 <- fvade(v,D,xi,'r') ## Loading required package: Matrix G1 <- fvade(function(x)-1,function(x)0,xi,'r') epsilon <- 1e-1 uopt <- function(G1V)    {      u <- mu(xc,pmax(epsilon,-G1V))      u[1] <- 0      return(u)   } k <- function(u) sqrt(u) sol <- PolicyIterationSingular(G0,G1,k,uopt,do.minimize=FALSE) plot(xc,sol$V,type=\"l\",xlab=\"x\",ylab=expression(V(x)))   lines(xc,0.5*log(xc) - 0.5*log(xc[50]) + sol$V[50]) plot(xc,sol$u,type=\"l\",xlab=\"x\",ylab=expression(mu(x)))   lines(xc,xc^2,lty=\"dashed\") plot(xc,sol$pi,type=\"l\",xlab=\"x\",ylab=\"p.d.f.\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/FisheriesManagement.html","id":"the-time-varying-problem","dir":"Articles","previous_headings":"","what":"The time-varying problem","title":"Fisheries Management - a Numerical Optimal Control Problem","text":", demonstrate solve time-varying HJB equation time marching. particular reason problem, one imagine extensions system parameters vary time etc. Therefore include . time-varying problem runs backward iteration. set arrays value function optimal harvest. , row index corresponds state, column index corresponds time. fill last column \\(V\\) terminal condition, take 0. backward iteration works two steps: First, use \\(V(\\cdot,t)\\) identify optimal control \\(\\mu(x)\\). specific current time step notation suppresses . Next, assume control strategy applied preceding time interval. end, write equation value function \\[ \\dot V + G_{cl}V + k = 0 \\] \\(G_{cl}\\) closed loop generator, \\(k\\) running reward current control strategy. example, \\(G_{cl}\\) discretizes operator \\[ x(1-x)V' - \\mu(x)V' + \\frac 12 \\sigma^2 V''  \\] \\(\\mu(x)\\) fixed. Similarly, \\(k\\) vector evaluates \\(\\sqrt{\\mu(x)}\\). solve equation exactly, .e., without time discretization error, write coupled system \\(\\dot k = 0\\) solve combined system. Let \\(Z = (V,k)\\), \\[ - \\dot Z = \\left[ \\begin{array}{cc} G_{cl} & \\\\ 0 & 0 \\end{array} \\right] Z \\] solve system using matrix exponential. top half elements solution previous time step. following plot shows value function various points time. Notice quite quickly seems enter steady state value function just shifted amount time step previous. reflects problem effectively steady state : control horizon long compared mixing time controlled process. shift corresponds \\(\\gamma\\), pay-rate steady state. red line analytical result steady-state problem.  following contour plot shows optimal control function time state. Note fish hard close terminal time, since problem include terminal reward leaving fish system end time.","code":"T <- 10 dt <- 1  tv <- seq(0,T,dt)  V <- U <- array(NA,c(length(xc),length(tv))) V[,length(tv)] <- 0 OO <- sparseMatrix(i=numeric(0),j=numeric(0),x=0,dims=c(length(xc),2*length(xc)))  for(i in length(tv):2) {   ## Find optimal control strategy   u <- uopt(G1 %*% V[,i])   U[,i-1] <- u      ## Construct the \"closed loop\" system that results from applying this control strategy   Gcl <- G0 + Diagonal(x=u) %*% G1      GG <- rbind(cbind(Gcl,Diagonal(n=length(xc),x=1)),OO)   Vkterm <- c(V[,i],k(u))   Vksol <- expm(GG*dt) %*% Vkterm   V[,i-1] <- Vksol[1:length(xc)] } matplot(xc,V,type=\"l\",col=1,lty=1,xlab=\"x\") lines(xc,0.5*log(xc)-0.5*log(xc[50])+V[50,1],lty=\"dashed\",col=\"red\") contour(tv,xc,t(U),levels=seq(0,3,0.25)^2,xlab=\"t\",ylab=\"x\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/FisheriesManagement.html","id":"implicit-euler-time-stepping","dir":"Articles","previous_headings":"","what":"Implicit Euler time stepping","title":"Fisheries Management - a Numerical Optimal Control Problem","text":"matrix exponential previous expensive large problems. therefore give variant code uses implicit Euler time step HJB equation rather matrix exponential. equation time discretized \\[ \\frac 1h (V_t - V_{t-h} ) + G_{cl} V_{t-h} + k = 0 \\] .e., \\[   V_{t-h} = (- G_{cl} h)^{-1} (V_t + hk) \\] repeat two previous plots. Note transients slightly different due coarse time step, steady state .","code":"for(i in length(tv):2) {   ## Find optimal control strategy   u <- uopt(G1 %*% V[,i])   U[,i-1] <- u      ## Construct the \"closed loop\" system that results from applying this control strategy   Gcl <- G0 + Diagonal(x=u) %*% G1      V[,i-1] <- as.numeric(solve(Diagonal(n=length(xc),x=1) - Gcl*dt,V[,i] + dt*k(u))) } matplot(xc,V,type=\"l\",col=1,lty=1,xlab=\"x\") lines(xc,0.5*log(xc)-0.5*log(xc[50])+V[50,1],lty=\"dashed\",col=\"red\") contour(tv,xc,t(U),levels=seq(0,3,0.25)^2,xlab=\"t\",ylab=\"x\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/HMM-filtering-of-scalar-SDEs.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"HMM filtering of scalar SDEs","text":"simulate sample path Ito stochastic differential equation governing abundance bacterial population \\[ dX_t = (1- X_t) ~dt + \\gamma \\sqrt{X_t} ~dB_t \\] Cox-Ingersoll-Ross model. , simulate random measurements taken times \\(0,dt,2~dt, \\ldots, T\\) \\(Y_i | X_{t_i}\\) Poisson distributed mean \\(v `. X_{t_i}\\). , pretend don’t know states re-estimate measurements.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/HMM-filtering-of-scalar-SDEs.html","id":"simulation-of-states","dir":"Articles","previous_headings":"","what":"Simulation of states","title":"HMM filtering of scalar SDEs","text":"define model simulate states using Euler-Marruyama method.","code":"require(SDEtools) ## Loading required package: SDEtools # Define model. Note abs to handle negative x.   gamma <- 1   f = function(x) (1-x)   g = function(x) gamma * sqrt(abs(x));    ## Time vector for simulation   dt = 0.001;   Tmax = 20;    tvec = seq(0,Tmax,dt)   nt <- length(tvec)    ## Initial condition, chosen somewhat arbitrarily   x0 <- 0.1    ## Enforce that the simulated state should be non-negative   p <- function(x) abs(x)      ## Simulate states    sim <- euler(f,g,tvec,x0,p=p)      plot(sim$times,sim$X,type=\"l\",xlab=\"Time\",ylab='Abundance')"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/HMM-filtering-of-scalar-SDEs.html","id":"simulation-of-measurements","dir":"Articles","previous_headings":"","what":"Simulation of measurements","title":"HMM filtering of scalar SDEs","text":"Next, generate random measurements. Measurements taken regular points time; every time point state values simulated. use Poisson distribution measurements. correspond situation count number individuals small sample environment.","code":"## Generate random measurements   tsample <- 0.1   vsample <- 1    sampleIndeces <- round(seq(1,length(tvec),(tsample/dt)))   tm = tvec[sampleIndeces];   xtrue <- sim$X[sampleIndeces]   ymean = vsample * xtrue    # Generate random measurements   ymeas <- rpois(length(tm),lambda=ymean)    plot(sim$times,sim$X,type=\"l\",xlab=\"Time\",ylab='Abundance')   points(tm,ymeas/vsample,pch='o')"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/HMM-filtering-of-scalar-SDEs.html","id":"specification-of-the-likelihood-function","dir":"Articles","previous_headings":"","what":"Specification of the likelihood function","title":"HMM filtering of scalar SDEs","text":"run filter, must first specify likelihood function. first define general measurement general state: can now inspect state likelihood , .e., without using process equation. choose discretization state space. choose use grid higher resolution near 0, tabulate likelihood function.  plot likely state, given just measurements, top true states:  little information individual observation, counts low. Therefore, potential gain estimating state just using measurement taken time, also neighbouring measurements. particularly measurements taken quite frequently: sample interval 0.1 time unit, mean relaxes time scale 1.","code":"## State likelihood      dl <- function(x,y) dpois(y,lambda=vsample*x) ## Choose discretization of state space   xi <- seq(0,3,0.025)^2                                # Cell Interfaces   xc <- cell.centers(xi)    ltab <- outer(xc,ymeas,dl)   image(tm,xc,t(ltab),xlab=\"Time\",ylab=\"State\") plot(tm,xtrue,type=\"l\") points(tm,xc[apply(ltab,2,which.max)])"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/HMM-filtering-of-scalar-SDEs.html","id":"running-the-filter","dir":"Articles","previous_headings":"","what":"Running the filter","title":"HMM filtering of scalar SDEs","text":"now use filter add information process equation. use function HMMfilterSDE, require process model well likelihood function. addition, needs distribution initial state. focus real-time state estimation; .e., use current past measurements estimation, future measurements.","code":"# Advection-diffusion form of the Kolmogorov equations   D = function(x) 0.5*gamma^2*x;   u = function(x) f(x) - 0.5*gamma^2;    ## Specify prior c.d.f. of the initial state, here uniform. Note that it does not have to be normalized.   phi0 <- function(x)x   ## Run the filter    filter <- HMMfilterSDE(u,D,xi,bc='r',phi0,tm,ymeas,dl) ## Loading required package: Matrix ## Show colour plot of posterior c.d.f.   image(tm,xc,t(apply(filter$psi,1,cumsum)),ylim=c(0,4))"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/HMM-filtering-of-scalar-SDEs.html","id":"filtering-results","dir":"Articles","previous_headings":"","what":"Filtering results","title":"HMM filtering of scalar SDEs","text":"compare true states estimated ones:  Notice estimated states lag bit behind true ones, fast fluctuations true states reflect estimated ones. features expected. can compare expectation variance posterior distribution:   Note seems roughly linear relationship (save first couple data points, reflect transients initial condition). linear relationship reflects process noise measurement noise: state large, process noise increased, variance measurements larger.","code":"## Plot true state at times of measurements   plot(tm,ymean/vsample,type=\"l\",xlab=\"t\",ylab=\"x\")    ## Compute and plot posterior mean   XestMean <- filter$psi %*% xc   points(tm,XestMean) XestVar <- filter$psi %*% xc^2 - XestMean^2 plot(tm,XestVar) plot(XestMean,XestVar)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/HMM-filtering-of-scalar-SDEs.html","id":"perspectives","dir":"Articles","previous_headings":"","what":"Perspectives","title":"HMM filtering of scalar SDEs","text":"function HMMfilterSDE can also gived “smoothed” states, .e., estimates based measurements, past future. can compare performance estimates shown , smoothed estimates. also estimate states measurements, example state likelihood function constant 1 whenever measurement taken. , investigate posterior variance evolves times measurements.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/ItoIntegrals.html","id":"numerical-itô-integration","dir":"Articles","previous_headings":"","what":"Numerical Itô integration","title":"Itô Integrals and the Euler-Maruyama method","text":"consider integrator \\(\\{B_t\\}\\) integrand \\(\\{G_t\\}\\), stochastic processes. Think \\(\\{B_t\\}\\) Brownian motion \\(\\{G_t\\}\\) adapted process, although necessary. aim approximate Itô integral \\[ I_t = \\int_0^t G_s ~dB_s \\] numerically, different values \\(t\\). Given time discretization \\(0=t_0 < t_1 < \\cdots < t_n\\), numerical Itô integral given \\[ I_0 = 0, \\quad I_{t_i+1} = I_{t_{}} + G_{t_i} (B_{t_{+1}}- B_{t_i}) \\mbox{ } = 0,1,\\ldots,n-1. \\] assumes \\(\\{G_t\\}\\) piecewise constant time points \\(t_i\\). approximation implemented function itointegral. example, can integrate Brownian motion w.r.t. :  included analytical result. agreement perfect; time discretization error. Note numerical Itô integration routine need know time grid; values integrator integrand time point. integral implemented follows:","code":"require(SDEtools) ## Loading required package: SDEtools t <- seq(0,1,0.01)   B <- rBM(t)   I <- itointegral(B,B)   plot(t,I,type=\"l\")     lines(t,0.5*(B^2-t),col=\"red\") print(itointegral) ## function (G, B)  ## { ##     return(c(0, cumsum(G[-length(G)] * diff(B)))) ## } ## <bytecode: 0x55e8e1cef210> ## <environment: namespace:SDEtools>"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/ItoIntegrals.html","id":"itô-integrals-and-the-euler-maruyama-method","dir":"Articles","previous_headings":"","what":"Itô integrals and the Euler-Maruyama method","title":"Itô Integrals and the Euler-Maruyama method","text":"Note numerical Itô integral essentially Euler-Maruyama solution stochastic differential equation: \\[ dI_t = G_t ~dB_t \\] see strong coupling Euler-Maruyama method numerical Itô integration. verify , consider Itô stochastic differential equation \\[ dX_t = f(X_t) ~dt + g(X_t) ~dB_t \\] initial condition \\(X_0=0\\), \\(f(x)=x-x^3\\) \\(g(x) = \\sqrt{1+x^2}\\):  solution, \\[ X_t = \\int_0^t f(X_s) ~ds + \\int_0^t g(X_s) ~dB_s .  \\] following code compares Euler-Maruyama discretization stochastic differential equation numerical Itô integral:  Note seem fit perfectly. fact, error roughly machine precision: , time discretization error use principle time discretization Euler-Maruyama method numerical Itô integral.","code":"f <- function(x) x -x^3    g <- function(x) sqrt(1 + x^2)   X <- SDEtools::euler(f,g,t,0,B=B)$X   plot(t,X,type=\"l\") plot(t,X,type=\"l\")   lines(t,itointegral(f(X),t)+itointegral(g(X),B),col=\"red\") print(max(abs(X-itointegral(f(X),t)-itointegral(g(X),B)))) ## [1] 6.661338e-16"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/ItoIntegrals.html","id":"numerical-itô-integration-w-r-t--other-processes","dir":"Articles","previous_headings":"","what":"Numerical Itô integration w.r.t. other processes","title":"Itô Integrals and the Euler-Maruyama method","text":"can perform numerical Itô integration process respect process, even nice properties Itô integral (martingale property Itô isometry) need hold. following, demonstrate recomputing Brownian motion: \\[   dB_t = \\frac{1}{g(X_t)} ~ dX_t - \\frac{f(X_t)}{g(X_t)} ~dt \\]  , error machine precision time discretization error:","code":"W <- itointegral(1/g(X),X) - itointegral(f(X)/g(X),t)   plot(t,W,type=\"l\")   lines(t,B,col=\"red\") print(max(abs(B-W))) ## [1] 6.661338e-16"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/ItoIntegrals.html","id":"numerical-stratonovich-integration","dir":"Articles","previous_headings":"","what":"Numerical Stratonovich integration","title":"Itô Integrals and the Euler-Maruyama method","text":"can repeat previous Stratonovich integrals \\[ \\int_0^t G_s \\circ dB_s \\] example, can integrate Brownian motion respect :  , see reasonable agreement numerical analytical result, even perfect, due time discretization. difference Itô Stratonovich integral comes quadratic cross-variation integrator integrand. following code figure compare Itô Stratonovich integrals \\[   ^i_t = \\int_0^t G_s ~dX_s ,    ^s_t = \\int_0^t G_s \\ring dX_s   \\] \\(G_s = B_s + X_s\\), well relationship two \\[ ^s_t = ^i_t + \\frac 12 \\langle G,X\\rangle_t .  \\]","code":"Is <- stochint(B,B,rule=\"c\") plot(t,Is,type=\"l\") lines(t,0.6*B^2,col=\"red\") G <- X+B Ii <- itointegral(G,X) Is <- stochint(G,X,rule=\"c\")  plot(t,Ii,type=\"l\") lines(t,Is,col=\"red\") points(t,Ii + 0.5 * CrossVariation(G,X))"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/ItosFormula.html","id":"verifying-itôs-formula-through-simulation","dir":"Articles","previous_headings":"","what":"Verifying Itô’s formula through simulation","title":"Itô's formula","text":"Itô’s formula states \\[ dY_t = h'(X_t) ~dX_t + \\frac 12 h''(X_t) (dX_t)^2  \\] \\(\\{X_t\\}\\) Itô process \\(Y_t=h(X_t)\\). Moreover, \\[ dX_t = F_t ~dt + G_t ~dB_t \\] \\((dX_t)^2 = G_t^2 ~dt\\), \\[ dY_t = h'(X_t) F_t ~dt + h'(X_t) G_t ~dB_t + \\frac 12 h''(X_t) G_t^2 ~dt  \\] following verifies numerically specific example, \\(\\{X_t\\}\\) stochastic logistic growth:  now map process function \\(h(x)=\\log x\\) generate \\(Y_t=h(X_t)\\):  now verify first variant Itô’s formula:  discretization error, effectively truncating second order Taylor’s formula computing increments time step.  now second formulation:  discretization error, now also effect discretized quadratic variation Brownian motion exactly equal time. error turns larger, case:","code":"require(SDEtools) ## Loading required package: SDEtools f <- function(x) x*(1-x)   g <- function(x) 0.5*x      t <- seq(0,10,0.01)   B <- rBM(t)   x0 <- 0.1   X <- euler(f,g,t,x0,B)$X      plot(t,X,type=\"l\") h <- function(x) log(x)   hp <- function(x) 1/x   hpp <- function(x) -1/x^2    Y = h(X)   plot(t,Y,type=\"l\") plot(t,Y,type=\"l\") Y1 <- h(x0) + itointegral(hp(X),X) + 0.5*itointegral(hpp(X),QuadraticVariation(X)) lines(t,Y1,col=\"red\") plot(t,Y-Y1,type=\"l\") plot(t,Y,type=\"l\") Y2 <- h(x0) + itointegral(hp(X),X) + 0.5*itointegral(hpp(X)*g(X)^2,t) lines(t,Y2,col=\"green\") plot(t,Y-Y2,type=\"l\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/NumericalKolmogorov.html","id":"solution-using-the-matrix-exponential","dir":"Articles","previous_headings":"","what":"Solution using the matrix exponential","title":"Numerical Analysis of the Kolmogorov Equations","text":"now consider forward Kolmogorov equation \\[ \\dot \\phi = \\phi'' , \\quad \\phi(0,x) = \\delta(x-x0) \\] \\([0,1]\\) reflection boundary \\(\\{0,1\\}\\), corresponding reflected Brownian motion intensity \\(\\sigma=\\sqrt 2\\). solve using matrix exponential. avoids errors arising time discretization, expensive large matrices.  Note probability vector \\(\\phi\\) must multiplied \\(G\\) (extension, \\(\\exp (Gt)\\)) left.","code":"xi <- seq(0,1,0.01)   xc <- cell.centers(xi)      G <- fvade(function(x)0,function(x)1,xi,'r')   t <- 0.01   x0 <- 0.25   phi0 <- diff(xi > x0)      phit <- phi0 %*% expm(G*t)       plot(xc,phit,type=\"l\",xlab=\"x\",ylab=\"p.d.f.\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/NumericalKolmogorov.html","id":"implicit-euler-stepping","dir":"Articles","previous_headings":"","what":"Implicit Euler stepping","title":"Numerical Analysis of the Kolmogorov Equations","text":"matrix exponential computationally expensive. simpler solution use Euler scheme. Explicit Euler bad idea, requires small time step stability. use implicit Euler step:  solver uses sparsity system, quite effective. Note time step used Euler method quite large, time discretization error visible.","code":"I <- Diagonal(length(xc)) n <- 4 IGt <- t(I - t/n*G) phitEuler <- solve(IGt,phi0) for(i in 2:n) phitEuler <- solve(IGt,phitEuler) plot(xc,phitEuler,type=\"l\") lines(xc,phit,lty=\"dashed\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/NumericalKolmogorov.html","id":"periodic-boundaries","dir":"Articles","previous_headings":"","what":"Periodic boundaries","title":"Numerical Analysis of the Kolmogorov Equations","text":"previous done reflecting boundaries. imposes flux boundary zero. case, diffusion, implies homogenous Neumann boundary condition forward equation. can repeat study periodic boundary conditions:  Note now flux left boundary right. Whether use periodic reflecting boundaries, can find stationary distribution:  expected, stationary distribution uniform.","code":"G <- fvade(function(x)0,function(x)1,xi,'p')   phit <- phi0 %*% expm(G*t)    plot(xc,phit,type=\"l\",xlab=\"x\",ylab=\"p.d.f.\") rho <- StationaryDistribution(G)   plot(xc,rho/diff(xi),type=\"l\",ylim=c(0,1.2),xlab=\"x\",ylab=\"p.d.f.\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/NumericalKolmogorov.html","id":"absorbing-boundaries","dir":"Articles","previous_headings":"","what":"Absorbing boundaries","title":"Numerical Analysis of the Kolmogorov Equations","text":"Finally, can try absorbing boundaries. , two options: can extend state space absorbing boundary points; result Markov chain 102 states (100 inner states two boundary states). following, stead omit boundary.  absorbing boundaries, probability inside domain conserved, eventually vanish. stationary distribution, quasistationary distribution:  Theoretically, \\(\\sin \\pi x\\) (normalized) corresponding eigenvalue \\(-\\pi^2 \\approx -9.87\\), .e., expected time absorption roughly 0.1 time units, quasistationary state.","code":"G <- fvade(function(x)0,function(x)1,xi,'a')   phit <- phi0 %*% expm(G*t)    plot(xc,phit,type=\"l\",xlab=\"x\",ylab=\"p.d.f.\") rho <- QuasiStationaryDistribution(G) plot(xc,rho$vector/diff(xi),type=\"l\",main=rho$value,xlab=\"x\",ylab=\"q.s.d.\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/NumericalKolmogorov.html","id":"including-both-advection-and-diffusion","dir":"Articles","previous_headings":"","what":"Including both advection and diffusion","title":"Numerical Analysis of the Kolmogorov Equations","text":"now include advection: Add flow field directs towards center. , advection discretized first order upwind scheme: Note advection adds extra jumps direction advection. way discretizing quite coarse introduces numerical diffusion, important advantages: discretized system generator Markov chain, generator linear combination generator diffusion one advection. features make technique robust suitable demonstration. specific application, worthwhile explore higher-order methods, must carefully checked properties discretized system , consequences . can plot stationary distribution:  Without boundaries, Gaussian mean 0.5 variance \\(1/16\\), .e. standard deviation \\(1/4\\). visible solution, although effect boundaries perturb solution. Note also advection, -flux boundary condition longer homogeneous Neumann condition.","code":"u <- function(x) 16*(0.5-x)   D <- function(x) 1   G <- fvade(u,D,xi,'r') print(head(G,c(4,4))) ## 4 x 4 sparse Matrix of class \"dgCMatrix\" ##                                  ## [1,] -10784  10784      .      . ## [2,]  10000 -20768  10768      . ## [3,]      .  10000 -20752  10752 ## [4,]      .      .  10000 -20736 print(tail(G,c(4,4))) ## 4 x 4 sparse Matrix of class \"dgCMatrix\" ##         [,97]  [,98]  [,99] [,100] ##  [97,] -20736  10000      .      . ##  [98,]  10752 -20752  10000      . ##  [99,]      .  10768 -20768  10000 ## [100,]      .      .  10784 -10784 rho <- StationaryDistribution(G)   plot(xc,rho/diff(xi),type=\"l\",xlab=\"x\",ylab=\"p.d.f.\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/NumericalKolmogorov.html","id":"the-backward-equation","dir":"Articles","previous_headings":"","what":"The backward equation","title":"Numerical Analysis of the Kolmogorov Equations","text":"backward Kolmogorov equation advection-diffusion form \\[ -\\dot \\psi = u \\psi ' + (D\\psi')' \\] discretize , yields generator \\(G\\) forward equation, now view matrix operator column vectors. example, can find expected value \\(X_t\\), function initial condition \\(X_0=x\\):","code":"psit <- as.numeric(xc)   psi0 <- expm(G*t) %*% psit   plot(xc,psi0,type=\"l\",xlab=\"x\",ylab=expression(psi[0]))"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/NumericalKolmogorov.html","id":"varying-diffusivity","dir":"Articles","previous_headings":"","what":"Varying diffusivity","title":"Numerical Analysis of the Kolmogorov Equations","text":"Keep mind diffusivity varies space, drift field \\(f\\) stochastic differential equation equal advective field \\(u\\). Rather, SDE \\[ dX_t = f(X_t) ~dt + g(X_t) ~dB_t \\] forward equation \\[ \\dot \\phi = - (f\\phi)' + (\\frac 12 g^2 \\phi)'' = - (u\\phi - D \\phi')' \\] advection \\(u\\) diffusion \\(D\\) can found drift \\(f\\) noise intensity \\(g\\) \\[ D = \\frac 12 g^2, \\quad u = f - D' .  \\] code fvade uses advection-diffusion formalism. example, stochastic logistic growth \\(f(x)=x(1-x)\\) \\(g(x)= \\sigma x\\):","code":"sigma <- 0.5    f <- function(x) x*(1-x)   g <- function(x) sigma * x      gp <- function(x) sigma ## Implements the derivative g'(x)   D <- function(x) 0.5 * g(x)^2   Dp <- function(x) g(x)*gp(x)  ## Implements D'(x)   u <- function(x) f(x) - Dp(x)    xi <- seq(0,2,0.01)   xc <- cell.centers(xi)   G <- fvade(u,D,xi,'r')      rho <- StationaryDistribution(G)   plot(xc,rho/diff(xi),type=\"l\",xlab=\"x\",ylab=\"p.d.f.\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/NumericalKolmogorov.html","id":"non-equidistant-grids","dir":"Articles","previous_headings":"","what":"Non-equidistant grids","title":"Numerical Analysis of the Kolmogorov Equations","text":"Sometimes advantage use higher spatial resolution regions state space. case extra important keep mind fvade works probabilities grid cell, densities:  grid bit coarse, spatial discretization error , demonstrates principle.","code":"xi <- seq(0,sqrt(2),0.05)^2   xc <- cell.centers(xi)   G <- fvade(u,D,xi,'r')      rho <- StationaryDistribution(G)   plot(xc,rho/diff(xi),type=\"l\",xlab=\"x\",ylab=\"p.d.f.\")   points(xi,0*xi,pch=\"+\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/SDEtools.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"SDEtools","text":"install package, open R run Alternatively, clone github repo local machine “make install” , familiar make makefiles. load package ","code":"devtools::install_github(\"Uffe-H-Thygesen/SDEtools\") library(SDEtools)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/articles/SDEtools.html","id":"tour-of-features","dir":"Articles","previous_headings":"","what":"Tour of features","title":"SDEtools","text":"Please see vignettes showcase functionality.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Uffe Hogsbro Thygesen. Maintainer.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Thygesen UH (2023). SDEtools: Utilities Stochastic Differential Equations. https://github.com/Uffe-H-Thygesen/SDEtools, https://uffe-h-thygesen.github.io/SDEtools/.","code":"@Manual{,   title = {SDEtools: Utilities for Stochastic Differential Equations},   author = {Uffe Hogsbro Thygesen},   year = {2023},   note = {https://github.com/Uffe-H-Thygesen/SDEtools, https://uffe-h-thygesen.github.io/SDEtools/}, }"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/index.html","id":"sdetools","dir":"","previous_headings":"","what":"Utilities for Stochastic Differential Equations","title":"Utilities for Stochastic Differential Equations","text":"SDEtools provides functions analyzing models based stochastic differential equations (SDE’s). analysis include simulation sample paths, solving Kolmogorov equations govern transition probabilities, state estimation, optimal control.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Utilities for Stochastic Differential Equations","text":"can install development version SDEtools GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"Uffe-H-Thygesen/SDEtools\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Utilities for Stochastic Differential Equations","text":"basic example shows simulate sample path, compute transition probability, double well model:","code":"library(SDEtools) ## basic example code f <- function(x) x-x^3 g <- function(x) 0.5  tv <- seq(0,6,0.01) sim <- heun(f,g,tv,0)  plot(tv,sim$X,type=\"l\",ylim=c(-1.5,1.5))  xi <- seq(-1.5,1.5,0.01) xc <- cell.centers(xi)  D <- function(x) 0.5*g(x)^2 G <- fvade(f,D,xi,'r')  rho <- StationaryDistribution(G)  lines(200*rho,xc)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/CrossVariation.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-variation of two stochastic processes — CrossVariation","title":"Cross-variation of two stochastic processes — CrossVariation","text":"Cross-variation two stochastic processes","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/CrossVariation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-variation of two stochastic processes — CrossVariation","text":"","code":"CrossVariation(X, Y)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/CrossVariation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-variation of two stochastic processes — CrossVariation","text":"X numeric vector containing one process Y numeric vector, length X, containing process","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/CrossVariation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-variation of two stochastic processes — CrossVariation","text":"numeric vector, length X, giving quadratic cross-varation function time","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/CrossVariation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-variation of two stochastic processes — CrossVariation","text":"","code":"## Quadratic variation of Brownian motion times <- seq(0,10,0.01) B <- rBM(times) plot(times,CrossVariation(B,B),type=\"l\") abline(0,1,lty=\"dashed\")   ## Verifying Ito's formula X <- -times + B h <- dhdx <- dh2dx2 <- function(x) exp(x) Y <- h(X) plot(times,Y,type=\"l\")  Yi <- h(X[1]) + itointegral(dhdx(X),X) + 0.5*itointegral(dh2dx2(X),CrossVariation(X,X)) lines(times,Yi,col=\"blue\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/HMMfilterSDE.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate states in a scalar stochastic differential equation based on discretization to a HMM — HMMfilterSDE","title":"Estimate states in a scalar stochastic differential equation based on discretization to a HMM — HMMfilterSDE","text":"HMMfilterSDE computes state estimation discretely observed stochastic differential equation","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/HMMfilterSDE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate states in a scalar stochastic differential equation based on discretization to a HMM — HMMfilterSDE","text":"","code":"HMMfilterSDE(   u,   D,   xi,   bc,   x0dist,   tvec,   yvec,   lfun,   do.smooth = FALSE,   do.Viterbi = FALSE,   pfun = NULL )"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/HMMfilterSDE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate states in a scalar stochastic differential equation based on discretization to a HMM — HMMfilterSDE","text":"u function mapping state (numeric scalar) advective term (numeric scalar) D function mapping state (numeric scalar) diffusivity (numeric scalar) xi numerical grid. Numeric vector increasing values, giving cell boundaries bc String indicating boundary conditions. See details. x0dist Prior distribution initial state, specified c.d.f. vector length xi, start tvec Vector (increasing) time points observations taken yvec Vector observations time point lfun Likelihood function lfun(x,y) gives likelihood y given x .smooth want smoothing, predictive filtering / estimation? .Viterbi want probable state sequence, found Viterbi algorithm? pfun C.d.f. observations given states, .e. pfun(x,y) gives P(Y<=y | X = x). supplied, pseudo-prediction residuals computed","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/HMMfilterSDE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate states in a scalar stochastic differential equation based on discretization to a HMM — HMMfilterSDE","text":"list containing: phi tabulation predicitive probability densities psi tabulation estimated probability densities pi  (.smooth==TRUE) tabulation smoothed probability densities c   vector containing normalization constants time step","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/HMMfilterSDE.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Estimate states in a scalar stochastic differential equation based on discretization to a HMM — HMMfilterSDE","text":"Uffe Høgsbro Thygesen","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/PolicyIterationRegular.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve the optimal control problem using policy iteration, i.e. find the optimal strategy\nand value function for the case where the uncontrolled system is given by a subgenerator G0\n(either due to discounting or due to absorbing boundaries) — PolicyIterationRegular","title":"Solve the optimal control problem using policy iteration, i.e. find the optimal strategy\nand value function for the case where the uncontrolled system is given by a subgenerator G0\n(either due to discounting or due to absorbing boundaries) — PolicyIterationRegular","text":"Solve optimal control problem using policy iteration, .e. find optimal strategy value function case uncontrolled system given subgenerator G0 (either due discounting due absorbing boundaries)","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/PolicyIterationRegular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve the optimal control problem using policy iteration, i.e. find the optimal strategy\nand value function for the case where the uncontrolled system is given by a subgenerator G0\n(either due to discounting or due to absorbing boundaries) — PolicyIterationRegular","text":"","code":"PolicyIterationRegular(   G0,   G1,   k,   uopt,   iter.max = 1000,   tol = 1e-12,   do.minimize = TRUE,   do.return.QSD = FALSE )"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/PolicyIterationRegular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve the optimal control problem using policy iteration, i.e. find the optimal strategy\nand value function for the case where the uncontrolled system is given by a subgenerator G0\n(either due to discounting or due to absorbing boundaries) — PolicyIterationRegular","text":"G0 sub-generator uncontrolled system G1 list (sub-)generators control k running cost uopt list functions returning optional controls function iter.max = 1000 Maximum number iterations tol = 1e-12 Tolerance convergence .minimize=TRUE  .return.QSD=FALSE Compute return quasi-stationary distribution","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/PolicyIterationRegular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve the optimal control problem using policy iteration, i.e. find the optimal strategy\nand value function for the case where the uncontrolled system is given by a subgenerator G0\n(either due to discounting or due to absorbing boundaries) — PolicyIterationRegular","text":"list containing V: value function, vector element state u: optimal controls, matrix row state column control , .return.QSD==TRUE, qsd.value: decay rate quasi-stationary distribution (decay rate) qsd.vector: quasi-stationary distribution","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/PolicyIterationRegular.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve the optimal control problem using policy iteration, i.e. find the optimal strategy\nand value function for the case where the uncontrolled system is given by a subgenerator G0\n(either due to discounting or due to absorbing boundaries) — PolicyIterationRegular","text":"","code":"## Controlling a system to the boundary with minimum effort xi <- seq(-2,2,length=101) xc <- as.numeric(cell.centers(xi,c(0,1))$x) dx <- diff(xi)  G0 <- fvade(function(x)-x,function(x)1,xi,'a') #> Loading required package: Matrix Gp <- fvade(function(x)1,function(x)0,xi,'a') Gn <- fvade(function(x)-1,function(x)0,xi,'a')  uopt <- function(dV)pmax(0,-dV) k <- function(u) 1 + 0.5*u[,1]^2 + 0.5*u[,2]^2 sol <- PolicyIterationRegular(G0,list(Gp,Gn),k,list(uopt,uopt),do.return.QSD=TRUE)  par(mfrow=c(1,3)) plot(xc,sol$V,xlab=\"x\",ylab=\"Value function\",type=\"l\") plot(xc,sol$u[,1]-sol$u[,2],type=\"l\",xlab=\"x\",ylab=\"Optimal control\") plot(xc,sol$qsd.vector/dx,type=\"l\",xlab=\"x\",ylab=\"QSD\",main=sol$qsd.value)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/PolicyIterationSingular.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve the optimal control problem using policy iteration, i.e. find the optimal strategy\nand value function for the case where the uncontrolled system is given by a generator G0 — PolicyIterationSingular","title":"Solve the optimal control problem using policy iteration, i.e. find the optimal strategy\nand value function for the case where the uncontrolled system is given by a generator G0 — PolicyIterationSingular","text":"Solve optimal control problem using policy iteration, .e. find optimal strategy value function case uncontrolled system given generator G0","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/PolicyIterationSingular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve the optimal control problem using policy iteration, i.e. find the optimal strategy\nand value function for the case where the uncontrolled system is given by a generator G0 — PolicyIterationSingular","text":"","code":"PolicyIterationSingular(   G0,   G1,   k,   uopt,   iter.max = 1000,   tol = 1e-12,   do.minimize = TRUE )"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/PolicyIterationSingular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve the optimal control problem using policy iteration, i.e. find the optimal strategy\nand value function for the case where the uncontrolled system is given by a generator G0 — PolicyIterationSingular","text":"G0 generator uncontrolled system G1 list generators control k running cost uopt list functions returning optional controls function iter.max = 1000 Maximum number iterations tol = 1e-12 Tolerance convergence .minimize=TRUE","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/PolicyIterationSingular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve the optimal control problem using policy iteration, i.e. find the optimal strategy\nand value function for the case where the uncontrolled system is given by a generator G0 — PolicyIterationSingular","text":"list containing V: value function, vector element state u: optimal controls, matrix row state column control pi: stationary distribution controlled system gamma: expected running cost stationarity","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/PolicyIterationSingular.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve the optimal control problem using policy iteration, i.e. find the optimal strategy\nand value function for the case where the uncontrolled system is given by a generator G0 — PolicyIterationSingular","text":"","code":"require(SDEtools)  u <- function(x)0*x D <- function(x) 0*x + 0.25   xi <- seq(-2,2,length=201) xc <- 0.5*(head(xi,-1) + tail(xi,-1))  G0 <- fvade(u,D,xi,'r') Gp <- fvade(function(x)1,function(x)0,xi,'r') Gn <- fvade(function(x)-1,function(x)0,xi,'r')  uopt <- function(Wp) pmax(0,-Wp) k <- function(u) 0.5*xc^2 + 0.5*u[,1]^2 + 0.5*u[,2]^2  sol <- PolicyIterationSingular(G0,list(Gp,Gn),k,list(uopt,uopt))  par(mfrow=c(1,2)) plot(xc,sol$V,type=\"l\",xlab=\"x\",ylab=\"Value function\") plot(function(x)0.5*x^2+min(sol$V),from=-2,to=2,lty=\"dashed\",add=TRUE) plot(xc,sol$u[,1]-sol$u[,2],type=\"l\",xlab=\"x\",ylab=\"Control\") abline(0,-1,lty=\"dashed\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/QuadraticVariation.html","id":null,"dir":"Reference","previous_headings":"","what":"Discretized quadratic variation of a stochastic process — QuadraticVariation","title":"Discretized quadratic variation of a stochastic process — QuadraticVariation","text":"Discretized quadratic variation stochastic process","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/QuadraticVariation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discretized quadratic variation of a stochastic process — QuadraticVariation","text":"","code":"QuadraticVariation(X)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/QuadraticVariation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discretized quadratic variation of a stochastic process — QuadraticVariation","text":"X numeric vector containing process","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/QuadraticVariation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discretized quadratic variation of a stochastic process — QuadraticVariation","text":"numeric vector, length X, giving discretized quadratic variation function time","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/QuadraticVariation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discretized quadratic variation of a stochastic process — QuadraticVariation","text":"","code":"## Quadratic Variation of Brownian motion times <- seq(0,10,0.01) B <- rBM(times) plot(times,QuadraticVariation(B))   ## Quadratic Variation of an Ito integral G <- cos(B) X <- itointegral(G,B) plot(times,QuadraticVariation(X)) lines(times,itointegral(G^2,times))"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/QuasiStationaryDistribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the quasi-stationary distribution for a terminating Continuous Time Markov Chain — QuasiStationaryDistribution","title":"Compute the quasi-stationary distribution for a terminating Continuous Time Markov Chain — QuasiStationaryDistribution","text":"QuasiStationaryDistribution compute quasi-stationary distribution phi Continuous Time Markov Chain given sub-generator G, given equations phi","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/QuasiStationaryDistribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the quasi-stationary distribution for a terminating Continuous Time Markov Chain — QuasiStationaryDistribution","text":"","code":"QuasiStationaryDistribution(G, max.iter = 20, tol = 1e-16)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/QuasiStationaryDistribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the quasi-stationary distribution for a terminating Continuous Time Markov Chain — QuasiStationaryDistribution","text":"G Sub-generator CTMC: quadratic matrix non-negative -diagonal elements non-positive row sums","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/QuasiStationaryDistribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the quasi-stationary distribution for a terminating Continuous Time Markov Chain — QuasiStationaryDistribution","text":"list containing: vector, vector non-negative elements, containing stationary distribution value, corresponding eigenvalue.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/QuasiStationaryDistribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the quasi-stationary distribution for a terminating Continuous Time Markov Chain — QuasiStationaryDistribution","text":"","code":"xgrid <- seq(0,1,0.01) G <- fvade(u=function(x)5,D=function(x)1,xgrid=xgrid,bc=\"a\") sol <- QuasiStationaryDistribution(G) plot(cell.centers(xgrid),sol$vector/diff(xgrid),main=paste(\"Decay rate\",-sol$value))"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/StationaryDistribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the stationary distribution for a Continuous Time Markov Chain — StationaryDistribution","title":"Compute the stationary distribution for a Continuous Time Markov Chain — StationaryDistribution","text":"StationaryDistribution compute stationary distribution phi Continuous Time Markov Chain given generator G, given equations phi assumed two equations specify phi uniquely, .e. G generator ergodic chain.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/StationaryDistribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the stationary distribution for a Continuous Time Markov Chain — StationaryDistribution","text":"","code":"StationaryDistribution(G)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/StationaryDistribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the stationary distribution for a Continuous Time Markov Chain — StationaryDistribution","text":"G Generator CTMC: quadratic matrix non-negative -diagonal elements zero row sums","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/StationaryDistribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the stationary distribution for a Continuous Time Markov Chain — StationaryDistribution","text":"phi, vector many elements rows G, containing stationary distribution.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/StationaryDistribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the stationary distribution for a Continuous Time Markov Chain — StationaryDistribution","text":"","code":"G <- array(c(-2,1,2,-1),c(2,2)) phi <- StationaryDistribution(G)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/cell.centers.html","id":null,"dir":"Reference","previous_headings":"","what":"Get center of grid cells for a retangular grid — cell.centers","title":"Get center of grid cells for a retangular grid — cell.centers","text":"cell.centers takes rectangular grid returns coordinates cell centers field","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/cell.centers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get center of grid cells for a retangular grid — cell.centers","text":"","code":"cell.centers(xgrid, ygrid = NULL)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/cell.centers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get center of grid cells for a retangular grid — cell.centers","text":"xgrid Interfaces x-direction ygrid Interfaces y-direction (2D)","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/dLinSDE.html","id":null,"dir":"Reference","previous_headings":"","what":"Transition probabilities in a linear SDE dX = A*X*dt + u*dt + G*dB — dLinSDE","title":"Transition probabilities in a linear SDE dX = A*X*dt + u*dt + G*dB — dLinSDE","text":"Transition probabilities linear SDE dX = *X*dt + u*dt + G*dB","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/dLinSDE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transition probabilities in a linear SDE dX = A*X*dt + u*dt + G*dB — dLinSDE","text":"","code":"dLinSDE(A, G, t, x0 = NULL, u = NULL, S0 = 0 * A)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/dLinSDE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transition probabilities in a linear SDE dX = A*X*dt + u*dt + G*dB — dLinSDE","text":"system matrix, quadratic numeric array matrix G noise matrix, number rows t time, numeric scalar x0 Initial state u forcing. numeric vector matrix; see details S0 Initial variance","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/dLinSDE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transition probabilities in a linear SDE dX = A*X*dt + u*dt + G*dB — dLinSDE","text":"list containing St, variance state time t, , depending input arguments eAt, matrix maps X0 Xt, .e. expm(*t), provided x0==NULL EX, expectation state time t, provided x0 NULL","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/dLinSDE.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transition probabilities in a linear SDE dX = A*X*dt + u*dt + G*dB — dLinSDE","text":"returning EX, expectation time t, input u can specified follows: * NULL, case assumed absent equation * numeric vector element row . case u assumed constant * numeric array matrix number rows two columns. case u assumed   vary affinely time, equaling first column time 0 second column time t. computations optimized large systems, since rely vector form matrix equations use sparsity.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/dLinSDE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transition probabilities in a linear SDE dX = A*X*dt + u*dt + G*dB — dLinSDE","text":"","code":"# A scalar equation with no input (dLinSDE(-1,1,1)) #> $eAt #>           [,1] #> [1,] 0.3678794 #>  #> $St #>           [,1] #> [1,] 0.4323324 #>  # A scalar equation with constant input, starting in steady-state (dLinSDE(A=-1,G=1,t=3,x0=1,u=1,S0=0.5)) #> $EX #> [1] 1 #>  #> $St #>      [,1] #> [1,]  0.5 #>"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/euler.html","id":null,"dir":"Reference","previous_headings":"","what":"Euler simulation of an Ito stochastic differential equation dX = f dt + g dB — euler","title":"Euler simulation of an Ito stochastic differential equation dX = f dt + g dB — euler","text":"Euler simulation Ito stochastic differential equation dX = f dt + g dB","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/euler.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Euler simulation of an Ito stochastic differential equation dX = f dt + g dB — euler","text":"","code":"euler(f, g, times, x0, B = NULL, p = function(x) x)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/euler.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Euler simulation of an Ito stochastic differential equation dX = f dt + g dB — euler","text":"f function f(x) f(t,x) giving drift term SDE g function g(x) g(t,x) giving noise term SDE times numeric vector time points, increasing x0 numeric vector giving initial condition B sample path (multivariate) Browniań motion. omitted, sample drawn using rvBM p Optional projection function time poins projects state, e.g. enforce non-negativeness","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/euler.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Euler simulation of an Ito stochastic differential equation dX = f dt + g dB — euler","text":"","code":"times <- seq(0,10,0.1)  # Plot a sample path of the solution of the SDE dX=-X dt + dB plot(times,euler(function(x)-x,function(x)1,times,0)$X,type=\"l\")   # Plot a sample path of the solution of the 2D time-varying SDE dX=(AX + FU) dt + G dB  A <- array(c(0,-1,1,-0.1),c(2,2)) F <- G <- array(c(0,1),c(2,1))  f <- function(t,x) A %*% x + F * sin(2*t) g <- function(x) G  BM <- rBM(times)  plot(times,euler(f,g,times,c(0,0),BM)$X[,1],type=\"l\")  # Add solution corresponding to different initial condition, same noise  lines(times,euler(f,g,times,c(1,0),BM)$X[,1],type=\"l\",lty=\"dashed\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/fvade.html","id":null,"dir":"Reference","previous_headings":"","what":"Discretize scalar advection-diffusion equation using finite volumes — fvade","title":"Discretize scalar advection-diffusion equation using finite volumes — fvade","text":"fvade discretizes advection-diffusion equation dC/dt = -(u*C-D*C')' interval [,b] using finite-volume method.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/fvade.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discretize scalar advection-diffusion equation using finite volumes — fvade","text":"","code":"fvade(u, D, xgrid, bc, sparse = TRUE, diagonals = FALSE)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/fvade.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discretize scalar advection-diffusion equation using finite volumes — fvade","text":"u function mapping state (numeric scalar) advective term (numeric scalar) D function mapping state (numeric scalar) diffusivity (numeric scalar) xgrid numerical grid. Numeric vector increasing values, giving cell boundaries bc String indicating boundary conditions. See details. sparse logical indicating result returned sparse matrix diagonals logical indicating result returned list subdiagonal, diagonal, superdiagonal","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/fvade.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discretize scalar advection-diffusion equation using finite volumes — fvade","text":"quadratic matrix, generator approximating continuous-time Markov chain, length(xgrid)-1 columns","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/fvade.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Discretize scalar advection-diffusion equation using finite volumes — fvade","text":"Handling boundary conditions: Input argument bc single character, vector two characters, coding condition boundary follows:          'r': Reflecting boundary          'p': Periodic boundaries: Exit boundary re-enter          '': Absorbing boundaries. case G sub-generator          'c': Continue beyond boundary (experimental; read source)          'e': Return generator, Extended include absorbing boundaries Return value: function fvade returns generator (sub-generator) G continuous-time Markov Chain. chain jumps  cells defined xgrid. using generator solve Kolmogorov equations, note G operates  probabilities cell, probability density cell. distinction particularly important  grid non-uniform.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/fvade.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discretize scalar advection-diffusion equation using finite volumes — fvade","text":"","code":"# Generator of standard Brownian motion with unit drift on the unit interval, reflecting boundaries xi <- seq(0,1,0.05)    # Cell boundaries dx <- diff(xi)         # Cell widths xc <- xi[-1] - 0.5*dx  # Cell centers G <- fvade(function(x)1,function(x)0.5,seq(0,1,0.05),'r')  # Find the density of the stationary distribution phi <- StationaryDistribution(G)         # Find stationary probabilities phi <- phi/dx                            # Convert to densities plot(xc,phi,type=\"l\",xlab=\"x\",ylab=\"Stationary density\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/fvade2d.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute generator for a 2D advection-diffusion equation — fvade2d","title":"Compute generator for a 2D advection-diffusion equation — fvade2d","text":"fvade2d discretizes advection-diffusion equation dC/dt = -div ( u C - D grad C) rectangular domain using finite-volume method. , u=(ux,uy) D=diag(Dx,Dy)","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/fvade2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute generator for a 2D advection-diffusion equation — fvade2d","text":"","code":"fvade2d(   ux,   uy,   Dx,   Dy,   xgrid,   ygrid,   bc = list(N = \"r\", E = \"r\", S = \"r\", W = \"r\") )"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/fvade2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute generator for a 2D advection-diffusion equation — fvade2d","text":"ux function mapping state (x,y) advective term (numeric scalar) uy function mapping state (x,y) advective term (numeric scalar) Dx function mapping state (x,y) diffusivity (numeric scalar) Dy function mapping state (x,y) diffusivity (numeric scalar) xgrid numerical grid. Numeric vector increasing values, giving cell boundaries ygrid numerical grid. Numeric vector increasing values, giving cell boundaries bc Specification boundary conditions. See details.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/fvade2d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute generator for a 2D advection-diffusion equation — fvade2d","text":"quadratic matrix, generator approximating continuous-time Markov chain, (length(xgrid)-1)*(length(ygrid)-1) columns","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/fvade2d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute generator for a 2D advection-diffusion equation — fvade2d","text":"Boundary conditions: bc list elements N,E,S,W. element either   \"r\": Reflective boundary   \"\": Absorbing boundary: Assume absorbing boundary cell, included   \"e\": Extend include absorbing boundary cell   \"p\": Periodic. hitting boundary, state immediately transferred opposite boundary, e.g. N->S. Return value: function fvade returns generator (sub-generator) G continuous-time Markov Chain. chain jumps  cells defined xgrid ygrid. using generator solve Kolmogorov equations, note G operates  probabilities cell, probability density cell. distinction particularly important  grid non-uniform.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/fvade2d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute generator for a 2D advection-diffusion equation — fvade2d","text":"","code":"# Generator of a predator-prey model xi <- seq(0,1.5,0.02)     yi <- seq(0,1.6,0.02) xc <- 0.5*(utils::head(xi,-1)+utils::tail(xi,-1)) yc <- 0.5*(utils::head(yi,-1)+utils::tail(yi,-1))  ux <- function(x,y) x*(1-x)-y*x/(1+x) uy <- function(x,y) y*x/(1+x)-y/3 D <- function(x,y) 0.01  G <- fvade2d(ux,uy,Dx=D,Dy=D,xi,yi)  phiv <- StationaryDistribution(G) phim <- unpack.field(phiv,length(xc),length(yc)) image(xi,yi,t(phim))"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/heun.html","id":null,"dir":"Reference","previous_headings":"","what":"Heun's method for simulation of a Stratonovich stochastic differential equation dX = f dt + g dB — heun","title":"Heun's method for simulation of a Stratonovich stochastic differential equation dX = f dt + g dB — heun","text":"Heun's method simulation Stratonovich stochastic differential equation dX = f dt + g dB","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/heun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Heun's method for simulation of a Stratonovich stochastic differential equation dX = f dt + g dB — heun","text":"","code":"heun(f, g, times, x0, B = NULL, p = function(x) x)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/heun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Heun's method for simulation of a Stratonovich stochastic differential equation dX = f dt + g dB — heun","text":"f function f(x) f(t,x) giving drift term SDE g function g(x) g(t,x) giving noise term SDE times numeric vector time points, increasing x0 numeric vector giving initial condition B sample path (multivariate) Browniań motion. omitted, sample drawn using rvBM p Optional projection function time poins projects state, e.g. enforce non-negativeness","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/heun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Heun's method for simulation of a Stratonovich stochastic differential equation dX = f dt + g dB — heun","text":"","code":"times <- seq(0,10,0.1)  # Plot a sample path of the solution of the SDE dX=-X dt + dB plot(times,heun(function(x)-x,function(x)1,times,0)$X,type=\"l\")   # Plot a sample path of the solution of the 2D time-varying SDE dX=(AX + FU) dt + G dB  A <- array(c(0,-1,1,-0.1),c(2,2)) F <- G <- array(c(0,1),c(2,1))  f <- function(t,x) A %*% x + F * sin(2*t) g <- function(x) G  BM <- rBM(times)  plot(times,heun(f,g,times,c(0,0),BM)$X[,1],type=\"l\")  # Add solution corresponding to different initial condition, same noise  lines(times,euler(f,g,times,c(1,0),BM)$X[,1],type=\"l\",lty=\"dashed\")   # Solve geometric Brownian motion as a Stratonovich equation times <- seq(0,10,0.01) BM <- rBM(times) plot(times,heun(function(x)-0.1*x,function(x)x,times,1,BM)$X,type=\"l\",xlab=\"Time\",ylab=\"X\")  # Add solution of corresponding Ito equation lines(times,euler(function(x)0.4*x,function(x)x,times,1,BM)$X,lty=\"dashed\")   # Testing a case with non-commutative noise BM2 <- rvBM(times,2) matplot(times,heun(function(x)0*x,   function(x)diag(c(1,x[1])),times,c(0,0),BM2)$X,xlab=\"Time\",ylab=\"X\",type=\"l\")  # Add solution to the corresponding Ito equation matplot(times,euler(function(x)0*x,   function(x)diag(c(1,x[1])),times,c(0,0),BM2)$X,xlab=\"Time\",ylab=\"X\",type=\"l\",add=TRUE)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/itointegral.html","id":null,"dir":"Reference","previous_headings":"","what":"Ito integral of a stochastic process w.r.t. another — itointegral","title":"Ito integral of a stochastic process w.r.t. another — itointegral","text":"Ito integral stochastic process w.r.t. another","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/itointegral.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ito integral of a stochastic process w.r.t. another — itointegral","text":"","code":"itointegral(G, B)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/itointegral.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ito integral of a stochastic process w.r.t. another — itointegral","text":"G numeric vector containing integrator B numeric vector, length G, containing integrand","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/itointegral.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ito integral of a stochastic process w.r.t. another — itointegral","text":"numeric vector, length G, giving \"running integral\", .e. Ito integral function upper limit.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/itointegral.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ito integral of a stochastic process w.r.t. another — itointegral","text":"","code":"## Integration of Brownian motion w.r.t. itself times <- seq(0,10,0.01) BM <- rBM(times) I <- itointegral(BM,BM) matplot(times,cbind(I,0.5*BM^2-0.5*times),type=\"l\",xlab=\"Time\",ylab=\"Ito integral\",          main=\"Integral of B.M. w.r.t itself\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/lqr.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve the time-varying LQR (Linear Quadratic Regulator) problem — lqr","title":"Solve the time-varying LQR (Linear Quadratic Regulator) problem — lqr","text":"Solve time-varying LQR (Linear Quadratic Regulator) problem","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/lqr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve the time-varying LQR (Linear Quadratic Regulator) problem — lqr","text":"","code":"lqr(times, A, F, G, Q, R, P = NULL)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/lqr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve the time-varying LQR (Linear Quadratic Regulator) problem — lqr","text":"times numeric vector time points system matrix, n--n numeric array F control matrix, n--m numeric array G noise matrix, n--l numeric array Q state penalty running cost, n--n numeric array specifying quadratic form x running cost R control penalty running cost, m--m numeric array specifying quadratic form u running cost P terminal state penalty, n--n numeric array specifying quadratic form x terminal cost","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/lqr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve the time-varying LQR (Linear Quadratic Regulator) problem — lqr","text":"list containing times, , F, G, Q, R, P: input arguments S value function. length(times)*n*n array containing, time point, quadratic form x value function s value function. length(times) vector containing, time point, -set value function, .e. value x=0 L optimal control. length(times)*m*n array containing, time point, gain matrix Lt maps states optimal controls","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/lqr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve the time-varying LQR (Linear Quadratic Regulator) problem — lqr","text":"","code":"# Feedback control of a harmonic oscillator A <- array(c(0,1,-1,0),c(2,2)) F <- G <- array(c(0,1),c(2,1)) Q <- diag(rep(1,2)) R <- 1 times <- seq(0,10,0.1) sol <- lqr(times,A,F,G,Q,R) #> Loading required package: deSolve #>  #> Attaching package: ‘deSolve’ #> The following object is masked from ‘package:SDEtools’: #>  #>     euler matplot(-times,array(sol$S,c(length(times),length(A))),type=\"l\",xlab=\"Time\",ylab=\"Elements in S\") legend(\"topright\",c(\"xx\",\"xv\",\"vx\",\"vv\"),lty=c(\"solid\",\"dashed\",\"dashed\",\"dotted\"),col=1:4)  matplot(-times,array(sol$L,c(length(times),length(F))),type=\"l\",          xlab=\"Time\",ylab=\"Feedback control\",lty=c(\"solid\",\"dashed\")) legend(\"topright\",c(\"Position\",\"Velocity\"),lty=c(\"solid\",\"dashed\"),col=1:2)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/lyap.html","id":null,"dir":"Reference","previous_headings":"","what":"Algebraic Lyapunov equation A*X+X*t(A)+Q=0 — lyap","title":"Algebraic Lyapunov equation A*X+X*t(A)+Q=0 — lyap","text":"Algebraic Lyapunov equation *X+X*t()+Q=0","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/lyap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Algebraic Lyapunov equation A*X+X*t(A)+Q=0 — lyap","text":"","code":"lyap(A, Q)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/lyap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Algebraic Lyapunov equation A*X+X*t(A)+Q=0 — lyap","text":"quadratic matrix without eigenvalues imaginary axis Q symmetric matix dimension ","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/lyap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Algebraic Lyapunov equation A*X+X*t(A)+Q=0 — lyap","text":"X symmetric matrix dimension ","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/lyap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Algebraic Lyapunov equation A*X+X*t(A)+Q=0 — lyap","text":"asymptotically stable, Q positive semidefinite pair (,Q) controllable, X positive definite. Several similar results exist. implementation uses vectorization kronecker products employ sparsity, suitable small systems.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/lyap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Algebraic Lyapunov equation A*X+X*t(A)+Q=0 — lyap","text":"","code":"# A scalar example (lyap(-1,1)) #>      [,1] #> [1,]  0.5 # A harmonic oscillator (lyap(array(c(0,-1,1,-0.1),c(2,2)),diag(c(0,1)))) #>      [,1] [,2] #> [1,]    5    0 #> [2,]    0    5"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/pack.field.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a tabulated function on the plane to a vector — pack.field","title":"Convert a tabulated function on the plane to a vector — pack.field","text":"pack.field takes array (e.g., probabilities) produces vector.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/pack.field.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a tabulated function on the plane to a vector — pack.field","text":"","code":"pack.field(phi)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/pack.field.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a tabulated function on the plane to a vector — pack.field","text":"phi Array probabilities 2D grid","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/prob2pdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert cell probabilities to (average) probability densities — prob2pdf","title":"Convert cell probabilities to (average) probability densities — prob2pdf","text":"prob2pdf takes vector probabilities spatial grid (given end-points interfaces) computes average p.d.f. grid cell","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/prob2pdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert cell probabilities to (average) probability densities — prob2pdf","text":"","code":"prob2pdf(phi, xgrid, ygrid = c(0, 1))"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/prob2pdf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert cell probabilities to (average) probability densities — prob2pdf","text":"phi Vector probabilities xgrid Spatial grid ygrid Optional grid y-direction (see details)","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/prob2pdf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert cell probabilities to (average) probability densities — prob2pdf","text":"length(phi) must equal length(xgrid)-1, ygrid given, (length(xgrid)-1)*(length(ygrid)-1) ygrid given xgrid (ygrid, given) must strictly increasing","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/prob2pdf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert cell probabilities to (average) probability densities — prob2pdf","text":"","code":"xgrid <- seq(-2,2,length=10)^3 phi <- diff(pnorm(xgrid)) f <- prob2pdf(phi,xgrid) plot(utils::head(xgrid,-1),f,type=\"S\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/rBM.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a sample path of Brownian motion — rBM","title":"Simulate a sample path of Brownian motion — rBM","text":"Simulate sample path Brownian motion","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/rBM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a sample path of Brownian motion — rBM","text":"","code":"rBM(times, sigma = 1, B0 = 0, u = 0)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/rBM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a sample path of Brownian motion — rBM","text":"times numeric vector time points Brownian motion simulated sigma numeric scalar, noise level Brownian motion, defaults 1 B0 numeric scalar, initial condition (time=0) Brownian motion u numeric scalar, drift","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/rBM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a sample path of Brownian motion — rBM","text":"numeric vector, length times, containing simulated value Brownian motion","code":""},{"path":[]},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/rBM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a sample path of Brownian motion — rBM","text":"","code":"times <- 0:10 plot(times,rBM(times),type=\"b\",xlab=\"Time\",ylab=\"Brownian motion\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/rBrownianBridge.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a Brownian bridge — rBrownianBridge","title":"Simulate a Brownian bridge — rBrownianBridge","text":"Simulate Brownian bridge","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/rBrownianBridge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a Brownian bridge — rBrownianBridge","text":"","code":"rBrownianBridge(times, B0T = c(0, 0), sigma = 1)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/rBrownianBridge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a Brownian bridge — rBrownianBridge","text":"times numeric vector time points Brownian motion simulated B0T initial terminal condition; fixed value Brownian motion first last time points sigma scalar; noise level Brownian motion.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/rBrownianBridge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a Brownian bridge — rBrownianBridge","text":"numeric vector, length(times), containing sample path","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/rBrownianBridge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a Brownian bridge — rBrownianBridge","text":"","code":"times <- 10:20 BB <- rBrownianBridge(times,c(10,-10),2) plot(times,BB,type=\"b\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/rvBM.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a multivariate Brownian motion — rvBM","title":"Simulate a multivariate Brownian motion — rvBM","text":"Simulate multivariate Brownian motion","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/rvBM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a multivariate Brownian motion — rvBM","text":"","code":"rvBM(times, n = 1, sigma = rep(1, n), B0 = rep(0, n), u = rep(0, n))"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/rvBM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a multivariate Brownian motion — rvBM","text":"times numeric vector time points Brownian motion simulated n numeric scalar, dimension Brownian motion sigma noise level Brownian motion. vector length n, one dimension, scalar, case level applied dimensions. B0 initial condition, applicable time t=0. vector length n, one dimension, scalar, case initial condition applied dimensions. u Drift. optional numeric n-vector defaults vector zeros. supplied, linear drift (bias) added component.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/rvBM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a multivariate Brownian motion — rvBM","text":"numeric array, n*length(times), column containing sample path","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/rvBM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a multivariate Brownian motion — rvBM","text":"","code":"times <- 0:10 VB <- rvBM(times,3) matplot(times,VB,type=\"b\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/stochint.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrate one sample path of a stochastic process w.r.t. another,\nreturning the Ito integral, the Stratonovich integral, or the\n","title":"Integrate one sample path of a stochastic process w.r.t. another,\nreturning the Ito integral, the Stratonovich integral, or the\n","text":"Integrate one sample path stochastic process w.r.t. another, returning Ito integral, Stratonovich integral, \"right hand rule\".","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/stochint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrate one sample path of a stochastic process w.r.t. another,\nreturning the Ito integral, the Stratonovich integral, or the\n","text":"","code":"stochint(f, g, rule = \"l\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/stochint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrate one sample path of a stochastic process w.r.t. another,\nreturning the Ito integral, the Stratonovich integral, or the\n","text":"f numeric vector containing integrator g numeric vector, length f, containing integrand rule character vector indicating rule(s). Valid choices \"l\", \"r\", \"c\" \"left\", \"right\", \"center\", well combinations, e.g. c(\"l\",\"c\"). Optional defaults \"l\".","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/stochint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrate one sample path of a stochastic process w.r.t. another,\nreturning the Ito integral, the Stratonovich integral, or the\n","text":"numeric vector, length f, giving \"running integral\", .e. integral function upper limit.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/stochint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Integrate one sample path of a stochastic process w.r.t. another,\nreturning the Ito integral, the Stratonovich integral, or the\n","text":"","code":"## Integrating a cosine w.r.t. a sine times <- seq(0,2*pi,length=21) I <- stochint(cos(times),sin(times)) Ia <- 0.5*times+0.25*sin(2*times)  # Analytical result matplot(times,I,type=\"l\") lines(times,Ia,col=\"blue\",lwd=2)   ## Integration of Brownian motion w.r.t. itself times <- seq(0,10,0.01) BM <- rBM(times) I <- stochint(BM,BM,c(\"l\",\"c\",\"r\")) matplot(times,cbind(I$l,0.5*BM^2-0.5*times),type=\"l\",xlab=\"Time\",ylab=\"Left integral (Ito)\",          main=\"Integral of B.M. w.r.t itself\")  matplot(times,cbind(I$r,0.5*BM^2+0.5*times),type=\"l\",xlab=\"Time\",ylab=\"Right integral\",          main=\"Integral of B.M. w.r.t itself\")  matplot(times,cbind(I$c,0.5*BM^2),type=\"l\",xlab=\"Time\",ylab=\"Central integral (Stratonovich)\",          main=\"Integral of B.M. w.r.t itself\")"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/unpack.field.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a vector to a function on the plane — unpack.field","title":"Convert a vector to a function on the plane — unpack.field","text":"unpack.field takes vector produces 2D array.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/unpack.field.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a vector to a function on the plane — unpack.field","text":"","code":"unpack.field(phi, nx, ny)"},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/unpack.field.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a vector to a function on the plane — unpack.field","text":"phi Tabulated function nx Number grid cells x direction ny Number grid cells y direction","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/reference/unpack.field.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert a vector to a function on the plane — unpack.field","text":"length(phi) must equal nx * ny.","code":""},{"path":"https://uffe-h-thygesen.github.io/SDEtools/news/index.html","id":"sdetools-01","dir":"Changelog","previous_headings":"","what":"SDEtools 0.1","title":"SDEtools 0.1","text":"Added NEWS.md file track changes package.","code":""}]
