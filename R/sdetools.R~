#' Simulate a sample path of Brownian motion
#'
#' @param times numeric vector of time points where the Brownian motion should be simulated
#' @param sigma numeric scalar, noise level in the Brownian motion, defaults to 1
#' @param B0 numeric scalar, initial condition (at time=0) for the Brownian motion
#' @param u numeric scalar, drift
#' @return numeric vector, of same length as times, containing the simulated value of the Brownian motion
#' @seealso \code{\link{rvBM}} for a vectorized version
#' @examples
#' times <- 0:10
#' plot(times,rBM(times),type="b",xlab="Time",ylab="Brownian motion")
#' 
#' @export
rBM <- function(times,sigma=1,B0=0,u=0)
{
  dt <- c(times[1],diff(times))
  dB <- rnorm(length(times),mean=u*dt,sd=sigma*sqrt(dt))
  B <- B0+cumsum(dB)
  return(B)
}

#' Simulate a multivariate Brownian motion
#'
#' @param times numeric vector of time points where the Brownian motion should be simulated
#' @param n numeric scalar, dimension of Brownian motion
#' @param sigma noise level in the Brownian motion. A vector of length n, one for each dimension, or a scalar, in which case the same level is applied to all dimensions.
#' @param B0 initial condition, applicable at time t=0. A vector of length n, one for each dimension, or a scalar, in which case the same initial condition is applied to all dimensions.
#' @return a numeric array, n*length(times), each column containing a sample path
#' @examples
#' times <- 0:10
#' VB <- rvBM(times,3)
#' matplot(times,VB,type="b")
#' 
#' @export
rvBM <- function(times,n=1,sigma=rep(1,n),B0=rep(0,n),u=rep(0,n))
{
  if(length(sigma)==1)sigma <- rep(sigma,n)
  if(length(B0)==1)B0 <- rep(B0,n)
  if(length(u)==1)u <- rep(u,n)
  return(sapply(1:n,function(i)rBM(times,sigma=sigma[i],B0=B0[i],u=u[i])))
}

#' Integrate one sample path of a stochastic process w.r.t. another
#' @param f numeric vector containing the integrator
#' @param g numeric vector, same length as f, containing the integrand
#' @param rule character indicating the rule. Valid choices are "l", "r", or "c" for "left", "right", and "center"
#' @return A numeric vector, same length as f, giving the "running integral", i.e. the integral as a function of the upper limit.
#' @examples
#' ## Integrating a cosine w.r.t. a sine
#' times <- seq(0,2*pi,length=21)
#' I <- stochint(cos(times),sin(times))
#' Ia <- 0.5*times+0.25*sin(2*times)  # Analytical result
#' matplot(times,I,type="l")
#' lines(times,Ia,col="blue",lwd=2)
#'
#' ## Integration of Brownian motion w.r.t. itself
#' times <- seq(0,10,0.01)
#' BM <- rBM(times)
#' I <- stochint(BM,BM)
#' matplot(times,cbind(I$l,0.5*BM^2-0.5*times),type="l",xlab="Time",ylab="Left integral (Ito)",
#'          main="Integral of B.M. w.r.t itself")
#' matplot(times,cbind(I$r,0.5*BM^2+0.5*times),type="l",xlab="Time",ylab="Right integral",
#'          main="Integral of B.M. w.r.t itself")
#' matplot(times,cbind(I$c,0.5*BM^2),type="l",xlab="Time",ylab="Central integral (Stratonovich)",
#'          main="Integral of B.M. w.r.t itself")
#'
#' 
#' @export
stochint <- function(f,g)
{
  n <- length(f)
  dg <- diff(g)
  l <- c(0,cumsum(f[-n]*dg))
  r <- c(0,cumsum(f[-1]*dg))
  c <- c(0,cumsum(0.5*(f[-n] + f[-1])*diff(g)))
  return(data.frame(l=l,r=r,c=c))
}

#' Covariation of two stochastic processes
#' @param X numeric vector containing the one process
#' @param Y numeric vector, same length as X, containing the other process
#' @return A numeric vector, same length as X, giving the covaration as function of time
#' @examples
#' ## Quadratic variation of Brownian motion
#' times <- seq(0,10,0.01)
#' B <- rBM(times)
#' plot(times,covariation(B,B),type="l")
#' abline(0,1,lty="dashed")
#'
#' ## Verifying Ito's formula
#' X <- -times + B
#' h <- dhdx <- dh2dx2 <- function(x) exp(x)
#' Y <- h(X)
#' plot(times,Y,type="l")
#'
#' Yi <- h(X[1]) + stochint(dhdx(X),X)$l + 0.5*stochint(dh2dx2(X),covariation(X,X))$l
#' lines(times,Yi,col="blue")
#' 
#' @export
covariation <- function(X,Y)
{
  return(c(0,cumsum(diff(X)*diff(Y))))
}

#' Heun's method for simulation of a Stratonovich stochastic differential equation dX = f dt + g dB
#' @param f function f(x) or f(t,x) giving the drift term in the SDE
#' @param g function g(x) or g(t,x) giving the noise term in the SDE
#' @param times numeric vector of time points, increasing
#' @param x0 numeric vector giving the initial condition
#' @param B sample path of (multivariate) Browniań motion. If omitted, a sample is drawn using rvBM
#' @examples
#' times <- seq(0,10,0.1)
#'
#' # Plot a sample path of the solution of the SDE dX=-X dt + dB
#' plot(times,heun(function(x)-x,function(x)1,times,0)$X,type="l")
#'
#' # Plot a sample path of the solution of the 2D time-varying SDE dX=(AX + FU) dt + G dB
#'
#' A <- array(c(0,-1,1,-0.1),c(2,2))
#' F <- G <- array(c(0,1),c(2,1))
#'
#' f <- function(t,x) A %*% x + F * sin(2*t)
#' g <- function(x) G
#'
#' BM <- rBM(times)
#'
#' plot(times,heun(f,g,times,c(0,0),BM)$X[,1],type="l")
#'
#' # Add solution corresponding to different initial condition, same noise
#'
#' lines(times,euler(f,g,times,c(1,0),BM)$X[,1],type="l",lty="dashed")
#'
#' # Solve geometric Brownian motion as a Stratonovich equation
#' times <- seq(0,10,0.01)
#' BM <- rBM(times)
#' plot(times,heun(function(x)-0.1*x,function(x)x,times,1,BM)$X,type="l",xlab="Time",ylab="X")
#'
#' # Add solution of corresponding Ito equation
#' lines(times,euler(function(x)0.4*x,function(x)x,times,1,BM)$X,lty="dashed")
#'
#' # Testing a case with non-commutative noise
#' BM2 <- rvBM(times,2)
#' matplot(times,heun(function(x)0*x,function(x)diag(c(1,x[1])),times,c(0,0),BM2)$X,xlab="Time",ylab="X",type="l")
#'
#' # Add solution to the corresponding Ito equation
#' matplot(times,euler(function(x)0*x,function(x)diag(c(1,x[1])),times,c(0,0),BM2)$X,xlab="Time",ylab="X",type="l",add=TRUE)
#' 
#' @export
heun <- function(f,g,times,x0,B=NULL)
{
  nx <- length(x0)
  nt <- length(times)

  ## Check if f is specified as a function(x) only, then convert to a function(t,x)
  if(length(formals(f))==1){
    ff <- function(t,x)f(x)
  }else
  {
    ff <- f
  }

  ## Check if g is specified as a function(x) only, then convert to a function(t,x)
  if(length(formals(g))==1){
    ggg <- function(t,x)g(x)
  }else
  {
    ggg <- g
  }

  ## Find number of dimensions of the Brownian motion. Convert g, if necessary, to something that
  ## returns a nx-by-nB matrix
  g0 <- ggg(times[1],x0)

  if(is.matrix(g0)){
    gg<-ggg
    nB <- ncol(g0)
  }else
  {
    nB <- 1
    gg <- function(t,x)matrix(ggg(t,x),nrow=nx,ncol=1)
  }

  ## If the sample path of Brownian motion is not specified, then simulate it
  if(is.null(B)){
    B <- rvBM(times,nB)
  }

  if(!is.matrix(B)) B <- matrix(B,nrow=nt,ncol=nB)

  dB <- apply(B,2,diff)

  X <- array(NA,c(nt,nx))
  X[1,] <- x0

  dt <- diff(times)

  for(i in 1:(nt-1))
  {
    ## Euler predictor
    fX <- ff(times[i],X[i,])
    gX <- gg(times[i],X[i,])
    Y <- X[i,] + fX*dt[i] + gX %*% dB[i,]

    ## Corrector
    fY <- ff(times[i+1],Y)
    gY <- gg(times[i+1],Y)
    X[i+1,] <- X[i,] + 0.5*(fX+fY)*dt[i] + 0.5*(gX+gY) %*% dB[i,]
  }

  return(list(times=times,X=X))
}


#' Euler simulation of an Ito stochastic differential equation dX = f dt + g dB
#' @param f function f(x) or f(t,x) giving the drift term in the SDE
#' @param g function g(x) or g(t,x) giving the noise term in the SDE
#' @param times numeric vector of time points, increasing
#' @param x0 numeric vector giving the initial condition
#' @param B sample path of (multivariate) Browniań motion. If omitted, a sample is drawn using rvBM
#' @param p Optional projection function that at each time poins projects the state, e.g. to enforce non-negativeness
#' @examples
#' times <- seq(0,10,0.1)
#'
#' # Plot a sample path of the solution of the SDE dX=-X dt + dB
#' plot(times,euler(function(x)-x,function(x)1,times,0)$X,type="l")
#'
#' # Plot a sample path of the solution of the 2D time-varying SDE dX=(AX + FU) dt + G dB
#'
#' A <- array(c(0,-1,1,-0.1),c(2,2))
#' F <- G <- array(c(0,1),c(2,1))
#'
#' f <- function(t,x) A %*% x + F * sin(2*t)
#' g <- function(x) G
#'
#' BM <- rBM(times)
#'
#' plot(times,euler(f,g,times,c(0,0),BM)$X[,1],type="l")
#'
#' # Add solution corresponding to different initial condition, same noise
#'
#' lines(times,euler(f,g,times,c(1,0),BM)$X[,1],type="l",lty="dashed")
#' 
#' @export
euler <- function(f,g,times,x0,B=NULL,p=function(x)x)
{
  nx <- length(x0)
  nt <- length(times)

  ## Check if f is specified as a function(x) only, then convert to a function(t,x)
  if(length(formals(f))==1){
    ff <- function(t,x)f(x)
  }else
  {
    ff <- f
  }

  ## Check if g is specified as a function(x) only, then convert to a function(t,x)
  if(length(formals(g))==1){
    ggg <- function(t,x)g(x)
  }else
  {
    ggg <- g
  }

  ## Find number of dimensions of the Brownian motion. Convert g, if necessary, to something that
  ## returns a nx-by-nB matrix
  g0 <- ggg(times[1],x0)

  if(is.matrix(g0)){
    gg<-ggg
    nB <- ncol(g0)
  }else
  {
    nB <- 1
    gg <- function(t,x)matrix(ggg(t,x),nrow=nx,ncol=1)
  }

  ## If the sample path of Brownian motion is not specified, then simulate it
  if(is.null(B)){
    B <- rvBM(times,nB)
  }

  if(!is.matrix(B)) B <- matrix(B,nrow=nt,ncol=nB)

  dB <- apply(B,2,diff)

  X <- array(NA,c(nt,nx))
  X[1,] <- x0

  dt <- diff(times)

  for(i in 1:(nt-1))
  {
    X[i+1,] <- p( X[i,] + ff(times[i],X[i,])*dt[i] + gg(times[i],X[i,]) %*% dB[i,] )
  }

  return(list(times=times,X=X))
}


#' Transition probabilities in a linear SDE dX = A*X*dt + u*dt + G*dB
#' @param A system matrix, quadratic numeric array or matrix
#' @param G noise matrix, same number of rows as A
#' @param t time, numeric scalar
#' @param x0 Initial state
#' @param u forcing. A numeric vector or matrix; see details
#' @param S0 Initial variance
#' @return A list containing St, the variance of the state at time t, and, depending on input arguments
#'
#'   eAt, the matrix that maps X0 to Xt, i.e. expm(A*t), provided x0==NULL
#'
#'   EX, the expectation of the state at time t, provided x0 is not NULL
#' @details
#' When returning EX, the expectation at time t, the input u can be specified as follows:
#'
#' * NULL, in which case it is assumed to be absent from the equation
#'
#' * a numeric vector with an element for each row in A. In this case u is assumed to be constant
#'
#' * a numeric array or matrix with same number of rows as A and two columns. In this case u is assumed
#'   to vary affinely in time, equaling the first column at time 0 and the second column at time t.
#' @examples
#' # A scalar equation with no input
#' (dLinSDE(-1,1,1))
#' # A scalar equation with constant input, starting in steady-state
#' (dLinSDE(A=-1,G=1,t=3,x0=1,u=1,S0=0.5))
#'
#' 
#' @export
dLinSDE <- function(A,G,t,x0=NULL,u=NULL,S0=0*A)
{
    G <- as.matrix(G)
    A <- as.matrix(A)

    GG <- G %*% t(G)

    nx <- nrow(A)

    eAt <- as.matrix(expm(A*t))

    I <- diag(rep(1,nx))
    M <- A %x% I + I %x% A
    P <- rbind(array(0,c(nx^2,2*nx^2)),cbind(diag(rep(1,nx^2)),M))
    gs <- expm(P*t) %*% c(as.numeric(GG),rep(0,nx^2))
    St <-eAt %*% S0 %*% t(eAt) + matrix(gs[nx^2+(1:(nx^2))],nrow=nx)

    if(is.null(x0)){
      return(list(eAt = expm(A*t),St = St))
    }

    if(is.null(u)){
      return(list(EX=expm(A*t) %*% x0,St=St))
    }

    if(length(u)==nx){
      AA <- rbind(array(0,c(nx,2*nx)),cbind(I,A))
      uEx <- expm(AA*t) %*% c(u,x0)
      return(list(EX=uEx[nx+(1:nx)],St=St))
    }

    u = as.matrix(u)

    if(all(dim(u)==c(nx,2))){
      O <- array(0,c(nx,nx))
      AAA <- rbind(cbind(O,O,O),
                   cbind(I,O,O),
                   cbind(O,I,A))
      duuEx <- expm(AAA*t) %*% c((u[,2]-u[,1])/t,u[,1],x0)
      return(list(EX=duuEx[2*nx+(1:nx)],St=St))
    }
}
